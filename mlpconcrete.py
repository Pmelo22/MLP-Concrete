# -*- coding: utf-8 -*-
"""MLPandRBF.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Aq_Fy29gD5rJMMsbHeBfp47pw8oUPpci
"""

import numpy as np
import pandas as pd
import tensorflow as tf
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from IPython.display import display

#  **Carregamento do dataset**
url = "https://archive.ics.uci.edu/ml/machine-learning-databases/concrete/compressive/Concrete_Data.xls"
df = pd.read_excel(url)

# **Renomeando colunas**
df.columns = [
    "Cement", "Blast_Furnace_Slag", "Fly_Ash", "Water",
    "Superplasticizer", "Coarse_Aggregate", "Fine_Aggregate", "Age", "Strength"
]

# **Separando variÃ¡veis de entrada (X) e saÃ­da (y)**
X = df.drop(columns=["Strength"])
y = df["Strength"]

# **Normalizando os dados**
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

#  **Dividindo os dados em treino e teste**
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)

# **Criando e treinando o modelo MLP**
model = tf.keras.Sequential([
    tf.keras.layers.Dense(64, activation='relu', input_shape=(X_train.shape[1],)),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(32, activation='relu'),
    tf.keras.layers.Dense(1)  # SaÃ­da para regressÃ£o
])

model.compile(optimizer='adam', loss='mse', metrics=['mae'])
history = model.fit(X_train, y_train, epochs=500, batch_size=32, validation_data=(X_test, y_test), callbacks=[tf.keras.callbacks.EarlyStopping(monitor='val_loss', patience=50, restore_best_weights=True)])

#  **FunÃ§Ã£o para prever a resistÃªncia do concreto com base na mistura inserida**
def prever_resistencia(nova_mistura):
    nova_mistura = np.array(nova_mistura).reshape(1, -1)
    nova_mistura = scaler.transform(nova_mistura)
    predicao = model.predict(nova_mistura).ravel()[0]
    return predicao

# **DicionÃ¡rio com resistÃªncia mÃ­nima recomendada para diferentes construÃ§Ãµes**
resistencia_recomendada = {
    "casa": 20,       # MPa
    "prÃ©dio": 25,     # MPa
    "ponte": 35,      # MPa
    "arranha-cÃ©u": 50 # MPa
}

#  **Solicitando informaÃ§Ãµes ao usuÃ¡rio**
print("\nğŸ“Œ Escolha o tipo de construÃ§Ã£o para anÃ¡lise:")
print("1 - Casa (MÃ­nimo 20 MPa)")
print("2 - PrÃ©dio (MÃ­nimo 25 MPa)")
print("3 - Ponte (MÃ­nimo 35 MPa)")
print("4 - Arranha-cÃ©u (MÃ­nimo 50 MPa)")

opcao = int(input("\nDigite o nÃºmero correspondente: "))
tipos = ["casa", "prÃ©dio", "ponte", "arranha-cÃ©u"]
tipo_construcao = tipos[opcao - 1]
resistencia_minima = resistencia_recomendada[tipo_construcao]

#  **Coletando dados da mistura de concreto**
print("\nğŸ”§ Agora, insira os ingredientes do concreto (em kg/mÂ³ dentro da faixa adequada):")
cimento = float(input("Cimento (kg/mÂ³) [100-600]: "))
escoria = float(input("EscÃ³ria de Alto-Forno (kg/mÂ³) [0-400]: "))
cinza = float(input("Cinzas Volantes (kg/mÂ³) [0-200]: "))
agua = float(input("Ãgua (kg/mÂ³) [120-250]: "))
plastificante = float(input("Superplastificante (kg/mÂ³) [0-30]: "))
agregado_grosso = float(input("Agregado GraÃºdo (kg/mÂ³) [700-1200]: "))
agregado_fino = float(input("Agregado MiÃºdo (kg/mÂ³) [500-1000]: "))
idade = int(input("Idade do Concreto (dias) [1-365]: "))

#  **Criando a mistura com os dados do usuÃ¡rio**
nova_mistura = [cimento, escoria, cinza, agua, plastificante, agregado_grosso, agregado_fino, idade]
resistencia_prevista = prever_resistencia(nova_mistura)

#  **Printando as mÃ©tricas do modelo**
y_pred = model.predict(X_test).ravel()
mae = mean_absolute_error(y_test, y_pred)
mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)
r2 = r2_score(y_test, y_pred)
mape = np.mean(np.abs((y_test - y_pred) / y_test)) * 100

print("\nğŸ“Š **MÃ©tricas do Modelo**")
print(f"MAE  (Erro Absoluto MÃ©dio)      : {mae:.4f} MPa  â†’ Em mÃ©dia, o erro das previsÃµes Ã© de {mae:.2f} MPa.")
print(f"MSE  (Erro QuadrÃ¡tico MÃ©dio)    : {mse:.4f}  â†’ Penaliza erros grandes, quanto menor, melhor.")
print(f"RMSE (Raiz do Erro QuadrÃ¡tico)  : {rmse:.4f} MPa  â†’ Mostra o erro mÃ©dio das previsÃµes.")
print(f"RÂ²   (Coeficiente de DeterminaÃ§Ã£o): {r2:.4f}  â†’ Indica que {r2:.2%} da variaÃ§Ã£o na resistÃªncia do concreto pode ser explicada pelo modelo.")
print(f"MAPE (Erro Percentual MÃ©dio)    : {mape:.2f}%  â†’ Erro mÃ©dio percentual das previsÃµes.")

#  **CÃ¡lculo da AcurÃ¡cia**
acuracia_final = 100 - mape  # AcurÃ¡cia baseada no erro percentual mÃ©dio

#  **ComparaÃ§Ã£o entre previsÃ£o e necessidade considerando o erro das previsÃµes (MAE)**
print("\nğŸ“Œ **AnÃ¡lise da Mistura de Concreto**")
print(f"- ResistÃªncia prevista pelo modelo: {resistencia_prevista:.2f} MPa")
print(f"- ResistÃªncia mÃ­nima necessÃ¡ria para {tipo_construcao}: {resistencia_minima} MPa")

# Considera o erro MAE para avaliar se a previsÃ£o ainda estÃ¡ dentro da margem de erro aceitÃ¡vel
limite_inferior = resistencia_prevista - mae
limite_superior = resistencia_prevista + mae

if resistencia_prevista >= resistencia_minima:
    print("âœ… O concreto estÃ¡ adequado para essa construÃ§Ã£o.")
elif limite_superior >= resistencia_minima:
    print("âš ï¸ O concreto estÃ¡ ligeiramente abaixo do ideal, mas dentro da margem de erro do modelo.")
    print(f"ğŸ” O modelo tem um erro mÃ©dio de Â±{mae:.2f} MPa, entÃ£o a previsÃ£o pode estar dentro da variaÃ§Ã£o esperada.")
else:
    print("âŒ O concreto pode nÃ£o ser seguro. Recomenda-se modificar a mistura para aumentar a resistÃªncia.")
    print(f"ğŸ” Mesmo considerando o erro mÃ©dio de Â±{mae:.2f} MPa, a resistÃªncia ainda pode ser insuficiente.")

#  **ExibiÃ§Ã£o da AcurÃ¡cia do Modelo**
print(f"\nğŸ“Š **AcurÃ¡cia do Modelo**: {acuracia_final:.2f}%")

#  **Plot Visual das PrevisÃµes**
plt.figure(figsize=(12, 5))
plt.bar(["ResistÃªncia Prevista", "ResistÃªncia NecessÃ¡ria"], [resistencia_prevista, resistencia_minima], color=["blue", "red"])
plt.ylabel("MPa")
plt.title("ComparaÃ§Ã£o de ResistÃªncia")
plt.show()

#  **GrÃ¡fico de EvoluÃ§Ã£o da AcurÃ¡cia**
plt.figure(figsize=(10, 5))
plt.plot(100 - np.array(history.history['val_mae']), label="AcurÃ¡cia (%)", color="green")
plt.xlabel("Ã‰pocas")
plt.ylabel("AcurÃ¡cia (%)")
plt.title("EvoluÃ§Ã£o da AcurÃ¡cia Durante o Treinamento")
plt.legend()
plt.show()