# -*- coding: utf-8 -*-
"""MLPandRBF.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Aq_Fy29gD5rJMMsbHeBfp47pw8oUPpci
"""

import numpy as np
import pandas as pd
import tensorflow as tf
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from IPython.display import display

#  **Carregamento do dataset**
url = "https://archive.ics.uci.edu/ml/machine-learning-databases/concrete/compressive/Concrete_Data.xls"
df = pd.read_excel(url)

# **Renomeando colunas**
df.columns = [
    "Cement", "Blast_Furnace_Slag", "Fly_Ash", "Water",
    "Superplasticizer", "Coarse_Aggregate", "Fine_Aggregate", "Age", "Strength"
]

# **Separando variáveis de entrada (X) e saída (y)**
X = df.drop(columns=["Strength"])
y = df["Strength"]

# **Normalizando os dados**
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

#  **Dividindo os dados em treino e teste**
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)

# **Criando e treinando o modelo MLP**
model = tf.keras.Sequential([
    tf.keras.layers.Dense(64, activation='relu', input_shape=(X_train.shape[1],)),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(32, activation='relu'),
    tf.keras.layers.Dense(1)  # Saída para regressão
])

model.compile(optimizer='adam', loss='mse', metrics=['mae'])
history = model.fit(X_train, y_train, epochs=500, batch_size=32, validation_data=(X_test, y_test), callbacks=[tf.keras.callbacks.EarlyStopping(monitor='val_loss', patience=50, restore_best_weights=True)])

#  **Função para prever a resistência do concreto com base na mistura inserida**
def prever_resistencia(nova_mistura):
    nova_mistura = np.array(nova_mistura).reshape(1, -1)
    nova_mistura = scaler.transform(nova_mistura)
    predicao = model.predict(nova_mistura).ravel()[0]
    return predicao

# **Dicionário com resistência mínima recomendada para diferentes construções**
resistencia_recomendada = {
    "casa": 20,       # MPa
    "prédio": 25,     # MPa
    "ponte": 35,      # MPa
    "arranha-céu": 50 # MPa
}

#  **Solicitando informações ao usuário**
print("\n📌 Escolha o tipo de construção para análise:")
print("1 - Casa (Mínimo 20 MPa)")
print("2 - Prédio (Mínimo 25 MPa)")
print("3 - Ponte (Mínimo 35 MPa)")
print("4 - Arranha-céu (Mínimo 50 MPa)")

opcao = int(input("\nDigite o número correspondente: "))
tipos = ["casa", "prédio", "ponte", "arranha-céu"]
tipo_construcao = tipos[opcao - 1]
resistencia_minima = resistencia_recomendada[tipo_construcao]

#  **Coletando dados da mistura de concreto**
print("\n🔧 Agora, insira os ingredientes do concreto (em kg/m³ dentro da faixa adequada):")
cimento = float(input("Cimento (kg/m³) [100-600]: "))
escoria = float(input("Escória de Alto-Forno (kg/m³) [0-400]: "))
cinza = float(input("Cinzas Volantes (kg/m³) [0-200]: "))
agua = float(input("Água (kg/m³) [120-250]: "))
plastificante = float(input("Superplastificante (kg/m³) [0-30]: "))
agregado_grosso = float(input("Agregado Graúdo (kg/m³) [700-1200]: "))
agregado_fino = float(input("Agregado Miúdo (kg/m³) [500-1000]: "))
idade = int(input("Idade do Concreto (dias) [1-365]: "))

#  **Criando a mistura com os dados do usuário**
nova_mistura = [cimento, escoria, cinza, agua, plastificante, agregado_grosso, agregado_fino, idade]
resistencia_prevista = prever_resistencia(nova_mistura)

#  **Printando as métricas do modelo**
y_pred = model.predict(X_test).ravel()
mae = mean_absolute_error(y_test, y_pred)
mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)
r2 = r2_score(y_test, y_pred)
mape = np.mean(np.abs((y_test - y_pred) / y_test)) * 100

print("\n📊 **Métricas do Modelo**")
print(f"MAE  (Erro Absoluto Médio)      : {mae:.4f} MPa  → Em média, o erro das previsões é de {mae:.2f} MPa.")
print(f"MSE  (Erro Quadrático Médio)    : {mse:.4f}  → Penaliza erros grandes, quanto menor, melhor.")
print(f"RMSE (Raiz do Erro Quadrático)  : {rmse:.4f} MPa  → Mostra o erro médio das previsões.")
print(f"R²   (Coeficiente de Determinação): {r2:.4f}  → Indica que {r2:.2%} da variação na resistência do concreto pode ser explicada pelo modelo.")
print(f"MAPE (Erro Percentual Médio)    : {mape:.2f}%  → Erro médio percentual das previsões.")

#  **Cálculo da Acurácia**
acuracia_final = 100 - mape  # Acurácia baseada no erro percentual médio

#  **Comparação entre previsão e necessidade considerando o erro das previsões (MAE)**
print("\n📌 **Análise da Mistura de Concreto**")
print(f"- Resistência prevista pelo modelo: {resistencia_prevista:.2f} MPa")
print(f"- Resistência mínima necessária para {tipo_construcao}: {resistencia_minima} MPa")

# Considera o erro MAE para avaliar se a previsão ainda está dentro da margem de erro aceitável
limite_inferior = resistencia_prevista - mae
limite_superior = resistencia_prevista + mae

if resistencia_prevista >= resistencia_minima:
    print("✅ O concreto está adequado para essa construção.")
elif limite_superior >= resistencia_minima:
    print("⚠️ O concreto está ligeiramente abaixo do ideal, mas dentro da margem de erro do modelo.")
    print(f"🔍 O modelo tem um erro médio de ±{mae:.2f} MPa, então a previsão pode estar dentro da variação esperada.")
else:
    print("❌ O concreto pode não ser seguro. Recomenda-se modificar a mistura para aumentar a resistência.")
    print(f"🔍 Mesmo considerando o erro médio de ±{mae:.2f} MPa, a resistência ainda pode ser insuficiente.")

#  **Exibição da Acurácia do Modelo**
print(f"\n📊 **Acurácia do Modelo**: {acuracia_final:.2f}%")

#  **Plot Visual das Previsões**
plt.figure(figsize=(12, 5))
plt.bar(["Resistência Prevista", "Resistência Necessária"], [resistencia_prevista, resistencia_minima], color=["blue", "red"])
plt.ylabel("MPa")
plt.title("Comparação de Resistência")
plt.show()

#  **Gráfico de Evolução da Acurácia**
plt.figure(figsize=(10, 5))
plt.plot(100 - np.array(history.history['val_mae']), label="Acurácia (%)", color="green")
plt.xlabel("Épocas")
plt.ylabel("Acurácia (%)")
plt.title("Evolução da Acurácia Durante o Treinamento")
plt.legend()
plt.show()